---
title: "二叉树非递归遍历实现"
date: 2018-10-04T17:34:10+08:00
draft: true
---

#### 主要是前序，中序和后序的非递归遍历
```cpp

#include <gtest/gtest.h>

#include <stack>
#include <memory>

template<typename T>
struct BTNode {
    BTNode *left = nullptr;
    BTNode *right = nullptr;
    T data;
};

template<typename T>
void visit(BTNode<T> *node, std::vector<T> &result) {
    if (node)
        result.push_back(node->data);
}

template<typename T>
void pre_order_non_recursion(BTNode<T> *node, std::vector<T> &result) {
    if (nullptr == node) {
        return;
    }
    std::stack<BTNode<T> *> node_stack;
    node_stack.push(node);
    while (!node_stack.empty()) {
        BTNode<T> *pop_node = node_stack.top();
        node_stack.pop();
        visit(pop_node, result);
        if (pop_node && nullptr != pop_node->right) {
            node_stack.push(pop_node->right);
        }
        if (pop_node && nullptr != pop_node->left) {
            node_stack.push(pop_node->left);
        }
    }
}

template<typename T>
void mid_order_non_recursion(BTNode<T> *node, std::vector<T> &result) {
    if (nullptr == node) {
        return;
    }
    std::stack<BTNode<T> *> node_stack;
    node_stack.push(node);
    BTNode<T> *top_node = node_stack.top();
    while (top_node && top_node->left) {
        node_stack.push(top_node->left);
        top_node = top_node->left;
    }
    while (!node_stack.empty()) {
        top_node = node_stack.top();
        node_stack.pop();
        visit(top_node, result);
        if (top_node && top_node->right) {
            node_stack.push(top_node->right);
            top_node = node_stack.top();
            while (top_node && top_node->left) {
                node_stack.push(top_node->left);
                top_node = top_node->left;
            }
        }
    }
}

template <typename T>
void post_order_non_recursion(BTNode<T>* node, std::vector<T>& result){
    if(nullptr == node){
        return;
    }
    std::stack<BTNode<T>*> stack_first;
    std::stack<BTNode<T>*> stack_second;
    stack_first.push(node);
    while(!stack_first.empty()){
        BTNode<T>* top_node = stack_first.top();
        stack_first.pop();
        stack_second.push(top_node);
        if(top_node&& top_node->left){
            stack_first.push(top_node->left);
        }
        if(top_node&&top_node->right){
            stack_first.push(top_node->right);
        }
    }
    while(!stack_second.empty()){
        BTNode<T>* top_node = stack_second.top();
        stack_second.pop();
        visit(top_node,result);
    }
}

/*                 1
 *
 *          2            3
 *
 *      4      5      6      7
 *
 *  8
 */
#define BUILD_SIMPLE_BINARY_TREE \
    auto node1 = std::make_shared<BTNode<int>>();node1->data=1; \
    auto node2 = std::make_shared<BTNode<int>>();node2->data=2; \
    auto node3 = std::make_shared<BTNode<int>>();node3->data=3; \
    auto node4 = std::make_shared<BTNode<int>>();node4->data=4; \
    auto node5 = std::make_shared<BTNode<int>>();node5->data=5; \
    auto node6 = std::make_shared<BTNode<int>>();node6->data=6; \
    auto node7 = std::make_shared<BTNode<int>>();node7->data=7; \
    auto node8 = std::make_shared<BTNode<int>>();node8->data=8; \
    node1->left=node2.get();\
    node1->right=node3.get();\
    node2->left=node4.get();\
    node2->right=node5.get();\
    node3->left=node6.get();\
    node3->right=node7.get();\
    node4->left = node8.get();

TEST(BinTree_Traverse, BinTree_Traverse_PreOrderNonRecursion) {
    BUILD_SIMPLE_BINARY_TREE
    std::vector<int> expect_result = {1, 2, 4, 8, 5, 3, 6, 7};
    std::vector<int> result;
    pre_order_non_recursion<int>(node1.get(), result);
    EXPECT_EQ(expect_result, result);
}

TEST(BinTree_Traverse, BinTree_Traverse_MidOrderNonRecursion) {
    BUILD_SIMPLE_BINARY_TREE
    std::vector<int> expect_result = {8, 4, 2, 5, 1, 6, 3, 7};
    std::vector<int> result;
    mid_order_non_recursion<int>(node1.get(), result);
    EXPECT_EQ(expect_result, result);
}

TEST(BinTree_Traverse, BinTree_Traverse_PostOrderNonRecursion) {
    BUILD_SIMPLE_BINARY_TREE
    std::vector<int> expect_result = {8, 4, 5,2,6,7,3,1};
    std::vector<int> result;
    post_order_non_recursion<int>(node1.get(), result);
    EXPECT_EQ(expect_result, result);
}


```